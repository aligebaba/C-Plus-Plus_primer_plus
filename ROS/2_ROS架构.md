
* ROS架构的三个层次：
    * **OS层**，基于Linux系统；
    * **中间层**，实现ROS核心通信机制以及机器人开发库；
        1. 基于TCPROS/UDPROS的通信系统。ROS的通信系统基于TCP/UDP网络，在此之上进行再次封装。
        2. Nodelet，一种进程内的通信方法，可以为多进程通信提供一种更优化的数据传输方式，适合对数据传输实时性方面有较高要求的应用。
    * **应用层**，在ROS Master的管理下保证功能节点的正常运行。

* 从系统实现角度，ROS可划分为三个层次：
    * **计算图**，描述程序是如何运行的。
        * *节点*（Node），一些执行运算任务的进程。一个系统一般由多个节点组成，可以称为“软件模块”。
        * *消息*（Message），一种严格的数据结构，支持标准数据类型（整形、浮点型、布尔型等），也支持嵌套结构和数组，还可以根据需求由开发者自主定义。
        * *话题*（Topic），消息以发布/订阅的方式传递（Publish/Subscribe），一个节点可以针对一个给定的*话题*发布消息（*发布者*，Talker），也可以关注某个*话题*并订阅特定类型的数据（*订阅者*，Listener）。发布者和订阅者并不了解彼此的存在。**一个*话题*可以被多个节点同时发布,也可以同时被多个节点接收。**
        * *服务*（Service），一种双向的同步传输模式，基于客户端/服务器模型（Client/Service），包含两个部分的通信数据类型：一个用于请求，另一个用于应答，类似于Web服务器。**ROS中只允许有一个节点提供指定命名的服务**。
        * *节点管理器*（ROS Master），使所有节点有条不紊地执行。ROS Master通过远程调用（RPC）提供登记列表和对其他计算图表的查找功能，帮助ROS节点之间相互查找、建立连接，同时还为系统提供参数服务器，管理全局参数。
    * **文件系统**，程序文件是如何组织和构建的。不同功能的文件被放置在不同的文件夹下。
        * *元功能包*（Meta Package），由原有功能包集（Stack）的概念升级而来，主要作用是组织多个用于同一目的的功能包。
        * *元功能包清单*，类似于功能包清单，不同之处在于其中可能包含运行时需要依赖的功能包，或者声明一些引用的标签。
        * *功能包*（Package），是ROS软件中的基本单元，包含ROS节点、库、配置文件。
        * *功能包清单*（Package Manifest），一个名为package.xml的文件，用于记录功能包的基本信息，包含作者信息、许可信息、依赖选项、编译标志等。
        * *消息*（Message），是ROS节点之间发布/订阅的通信信息，可以使用ROS提供的消息类型，也可以使用.msg文件在功能包的msg文件夹下自定义所需要的消息类型。
        * *服务*（Srevice），ROS客户端/服务器通信模型下的请求与应答数据类型，可以使用ROS提供的服务类型，也可以使用.srv文件在功能包的srv文件夹下进行自定义。
        * *代码*（Code），用来放置功能包节点源代码的文件夹。
    * **开源社区**，ROS资源是如何分布式管理的。
        * *发行版*（Distribution），可以通过软件集合来维持统一的版本号。
        * *软件源*（Repository），不同的组织机构可以开发或者共享自己的机器人软件。
        * *ROS wiki*，记录ROS信息文档的主要论坛。
        * *邮件列表*（Mailing List），ROS邮件列表是交流ROS更新的主要渠道。
        * *ROS Answer*，一个咨询ROS相关问题的网站。
        * *博客*（Blog），发布ROS社区中的新闻、图片、视频（http://www.ros.org/news）。

* 一个功能包的典型文件结构如下：
    * config：放置配置文件，由用户创建，文件名可以不同。
    * include：放置需要用到的头文件。
    * scripts：放置可以直接运行的Python脚本。
    * src：放置需要编译的C++代码。
    * launch：放置所有的启动文件。
    * msg：放置自定义的消息类型。
    * srv：放置自定义的服务类型。
    * action：放置自定义的动作指令。
    * CMakeLists.txt：编译器编译功能包的规则。
    *package.xml：功能包清单。

* ROS是一个分部式框架，为用户提供多节点（进程）之间的通信服务，所有软件功能和工具都建立在这种分布式通信机制上，所以ROS的通信机制是最底层也是最核心的技术。
* ROS中有两个节点：一个是发布者Talker，另一个是订阅者Listener。

* **话题通信机制**
    * 两个节点分别发布、订阅同一个话题，启动顺序没有强制要求。建立通信的详细过程大致分为七步：
    1. Talker注册
        * Talker启动，通过1234端口使用RPC向ROS Master注册发布者的信息，*包含所发布消息的话题名*。ROS Master会将节点的注册信息加入到注册列表中。
    2. Listener注册
        * Listener启动，同样通过RPC向ROS Master注册订阅者的信息，*包含需要订阅的话题名*。
    3. ROS Master进行信息匹配
        * Master根据Listener的订阅信息从注册表中进行查找，如果没有找到匹配的发布者，则等待发布者的加入；如果找到匹配的发布者信息，则*通过RPC向Listener发送Talker的RPC地址信息*。
    4. Listener发送连接请求
        * Listener接收到Master发回的Talker地址信息，尝试通过RPC向Talker发送连接请求，传输订阅的话题名、消息类型以及通信协议（TCP/UDP）
    5. Talker确认连接请求
        * Talker接收到Listener发送的连接请求后，继续通过RPC向Listener确认连接信息，其中包含自身的TCP地址信息。
    6. Listener尝试与Talker建立网络连接
        * Listener接收到确认信息后，使用TCP尝试与Talker建立网络连接。
    7. Talker向Listener发布数据
        * 成功建立连接后，Talker开始向Listener发送话题消息数据。
    
    * 前5个步骤使用的通信协议都是RPC，最后发布数据的过程才使用到TCP。
    * 节点建立连接后，可以关掉ROS Master，节点之间的数据传输并不会受到影响，但是其他节点也无法加入这两个节点之间的网络。

* **服务通信机制**
    * 与话题通信相比，其减少了Listener与Talker之间的RPC通信。
    1. Talker注册
        * Talker启动，通过1234端口使用RPC向ROS Master注册发布者的信息，*包含所提供的服务名*。ROS Master会将节点的注册信息加入到注册列表中。
    2. Listener注册
        * Listener启动，同样通过RPC向ROS Master注册订阅者的信息，*包含需要查找的服务名*。
    3. ROS Master进行信息匹配
        * Master根据Listener的订阅信息从注册表中进行查找，如果没有找到匹配的服务提供者，则等待该服务的提供者加入；如果找到匹配的服务提供者信息，则*通过RPC向Listener发送Talker的TCP地址信息*。
    4. Listener与Talker建立网络连接
        * Listener接收到确认信息后，使用TCP尝试与Talker建立网络连接，并发送服务的请求数据。
    5. Talker向Listener发布服务应答数据
        * Talker接收到服务请求和参数后，开始执行服务功能，执行完成后，向Listener发送应答数据。
    
* **参数管理机制**
    * 参数类似于ROS中的全局变量，由ROS Master进行管理，不涉及TCP/UDP的通信。
    1. Talker设置变量
        * Talker使用RPC向ROS Master发送参数设置数据，包含参数名和参数值；ROS Master将参数名和参数值保存到参数列表中。
    2. Listener查询参数值
        * Listener通过RPC向ROS Master发送参数数据查找请求，包含所要查找的参数名。
    3. ROS Master向Listener发送参数值
        * Master根据Listener的查找请求从参数列表中进行查找，查找到参数后，使用RPC将参数值发送给Listener。

    * 如果Talker向Master更新参数值，Listener在不重新查询参数值的情况下是无法知晓参数值以及被更新的。
    * 在很多应用场景中，需要一种动态参数更新的机制，详见ROS中的参数配置功能。