# 笔记 3 -- 复合数据类型

* **数组**能够存储多个同类型的值，通用格式如下：
    * `typeName arrayName[arraySize]`
    * `arraySize`指定元素数目，**不能是变量**，必须是整型常数或`const`值，也可以是常量表达式。

* C++数组从0开始编号。编译器不会检查使用的下标是否有效。
* **不能将一个数组赋给另一个数组**。
* `sizeof`运算符**用于数组名**，将得到整个数组中的字节数；`sizeof`运算符**用于数组元素**，将得到元素的字节数。

* 数组初始化方法：
    * 可省略等号（`=`）；
    * 可不在大括号内包含任何东西，这将把所有元素都设置为0；
    * 如果只对一部分元素进行初始化，则其他元素将被设置为0；
    * 初始化列表**禁止缩窄转换**。

***
* C-风格字符串
    * 特殊性质：**以空字符结尾**，空字符被写作`\0`，其ASCII为0，用来标记字符串的结尾。
    * 存储在连续字节中的一系列字符，意味着可以将字符串存储在char数组中，其中每个字符都位于自己的数组元素中。

* **字符串常量**或**字符串字面值**：用一对引号括起来的字符串（一种将字符数组初始化为字符串的方法）。
    * 用引号括起的字符串**隐式地包括结尾的空字符**。
    * 将字符串读入到char数组中时，将自动加上结尾的空字符。
    * C++对字符串长度没有限制。

* **字符串常量**（使用双引号）不能与**字符常量**（使用单引号）互换。例如：字符常量`'S'`只是数值83的另一种写法；而字符串常量`"S"`表示字符`S`和`\0`组成的字符串，而且"S"实际上表示的是该字符串所在的内存地址。

* C++运行拼接字符串常量，拼接时不会在连接的字符串之间添加空格。**第一个字符串中的`\0`字符将被第二个字符串中的第一个字符取代**。

* 标准头文件cstring：
    * `strlen()`只计算可见的字符，而不把空字符计算在内。
    * `strcpy()`将字符串复制到字符数组中。
    * `strcat()`将字符串附加到字符数组末尾。

* 由于不能通过键盘输入空字符，`cin`使用空白来确定字符串的结束位置（空格、制表符和换行符）。
    * `cin`提供了面向行的成员函数（类方法）：`getline()`和`get()`。
    * `getline()`通过回车键输入的换行符来确定输入结尾，并将**丢弃换行符**。`cin.getline(name, ArSize)`其第一个参数是用来**存储输入行的数组的名称**，第二个参数是**要读取的字符数**。
    * `get()`有两种变体。一种与`getline()`类似，接受的参数相同，但`get()`并**不再读取并丢弃换行符**；而不带任何参数的`cin.get()`可**读取下一个字符**（即使是换行符）。另一种是将两个成员函数拼接起来，如：`cin.get(name, ArSize).get()`,**由于`cin.get(name, ArSize)`返回一个`cin`对象**，随后可调用`get()`函数。
    * `get()`可用于判读停止读取的原因是读取了整行还是由于数组已填满。**因此，`getline()`使用起来更简单，而`get()`使得检测错误更简单**。
    * `get()`读取空行后将设置失效位（failbit）。可使用`cin.clear()`命令来恢复。
    * 如果输入行包含的字符数比指定的多，则`getline()`和`get()`将把余下的字符留在输入队列中，而`getline()`还会设置失效位，并关闭后面的输入。

***
* 使用string类，需要包含头文件string。
    * string类**位于名称空间std中**。
    * string类隐藏了字符串的数组性质，让程序员像处理普通变量那样处理字符串。
    * 不能将一个数组赋给另一个数组，但可以将一个string对象赋给另一个string对象。
    * 可使用运算符`+`将两个string对象合并起来。
    * `getline(cin,str)`将`cin`读取的输入保存到`str`中，此处的`getline()`不是类方法。

***
* **结构是用户定义的类型**，结构声明定义了这种类型的数据属性。创建结构包括两步：
    * 首先定义结构描述，描述并标记了能够存储在结构中的各种数据类型。
    * 然后按描述创建结构变量（结构数据对象）。

    * 列表中的每一项都被称为**结构成员**，可使用成员运算符`.`来访问各个成员。
    * C++允许在声明结构变量时**省略关键字`struct`**。
    * 可以同时完成定义结构和创建结构变量的工作，甚至初始化创建的变量，只需将变量名和初始化放在结束括号的后面即可。

* C++不提倡使用外部变量，但提倡使用外部结构声明。
* 结构可**使用列表初始化**，等号`=`可省略，不允许缩窄转换。
* 可以将结构作为参数传递给函数，也可以让函数返回一个结构。
* 可以将结构赋值给另一个同类型的结构。

* 可以创建元素为结构的数组，方法与创建基本类型数组完全相同。

* C++允许指定占用特定位数的结构成员，可以使用没有名称的字段来提供间距。每个成员都被称为**位字段**（位字段通常用在低级编程中）。

***
* **共用体是一种数据格式**，它能够存储不同的数据类型，但只能同时存储其中的一种类型。
    * 使用关键字`union`定义共用体。
    * 共用体的长度是其最大成员的长度。
    * 共用体常用于节省内存。
    * 共用体常用于操作系统数据结构或硬件数据结构。

***
* **枚举**提供了另一种创建符号常量的方式，这种方式可以替代`const`。它还允许定义新类型，但必须按严格的限制进行。
    * 使用关键字`enum`定义枚举。
    * 符号常量叫做**枚举量**。默认情况下将整数依次赋给枚举量（从0开始）。
    * 可用枚举名来声明这种类型的变量。
    * 在不进行强制类型转换时，只能将定义枚举时使用的枚举量赋给该枚举的变量。
    * 对于枚举，只定义了赋值运算符。
    * 枚举量是整型，可被提升为`int`类型，但`int`类型不能自动转换为枚举类型。
    * 可在算术表达式中同时使用枚举和常规整数。

* **枚举更常被用来定义相关的符号常量**。如果打算只使用常量，而不创建枚举类型的变量，则可省略枚举类型的名称。
    * 可创建多个值相同的枚举量。

* **每个枚举都有取值范围**，通过强制类型转换，可以将取值范围中的任何整数值赋给枚举变量，即使这个值不是枚举值。
    * 找出上限：找到大于这个最大值的、最小的2的幂，将它减去1便得到取值范围的上限。
    * 找出下限：若最小值不小于0，则取值范围的下限为0；否则，采用与寻找上限相同的方式，但要加上负号。

***
* **指针是一个变量**，其存储的是值的地址，而不是值本身。
    * 对变量应用**地址运算符`&`**，就可以获得它的地址。
    * 显示地址时，`cout`使用十六进制表示法。
    * 使用常规变量时，值是指定的量，而地址是派生的量。
    * 处理存储数据的策略刚好相反，它将地址视为指定的量，而将值视为派生量。
    * 对指针应用**解除引用运算符`*`**（间接值），可得到该地址存储的值。

* 面向对象编程强调在运行阶段进行决策（根据实际需要的而定）；而面向过程编程强调在编译阶段进行决策（预先确定好）。