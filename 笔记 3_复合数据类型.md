# 笔记 3 -- 复合数据类型

* **数组**能够存储多个同类型的值，通用格式如下：
    * `typeName arrayName[arraySize]`
    * `arraySize`指定元素数目，**不能是变量**，必须是整型常数或`const`值，也可以是常量表达式。

* C++数组从0开始编号。编译器不会检查使用的下标是否有效。
* **不能将一个数组赋给另一个数组**。
* `sizeof`运算符**用于数组名**，将得到整个数组中的字节数；`sizeof`运算符**用于数组元素**，将得到元素的字节数。

* 数组初始化方法：
    * 可省略等号（`=`）；
    * 可不在大括号内包含任何东西，这将把所有元素都设置为0；
    * 如果只对一部分元素进行初始化，则其他元素将被设置为0；
    * 初始化列表**禁止缩窄转换**。

***
* C-风格字符串
    * 特殊性质：**以空字符结尾**，空字符被写作`\0`，其ASCII为0，用来标记字符串的结尾。
    * 存储在连续字节中的一系列字符，意味着可以将字符串存储在char数组中，其中每个字符都位于自己的数组元素中。

* **字符串常量**或**字符串字面值**：用一对引号括起来的字符串（一种将字符数组初始化为字符串的方法）。
    * 用引号括起的字符串**隐式地包括结尾的空字符**。
    * 将字符串读入到char数组中时，将自动加上结尾的空字符。
    * C++对字符串长度没有限制。

* **字符串常量**（使用双引号）不能与**字符常量**（使用单引号）互换。例如：字符常量`'S'`只是数值83的另一种写法；而字符串常量`"S"`表示字符`S`和`\0`组成的字符串，而且"S"实际上表示的是该字符串所在的内存地址。

* C++允许拼接字符串常量，拼接时不会在连接的字符串之间添加空格。**第一个字符串中的`\0`字符将被第二个字符串中的第一个字符取代**。

* 标准头文件cstring：
    * `strlen()`只计算可见的字符，而不把空字符计算在内。
    * `strcpy()`将字符串复制到字符数组中。
    * `strncpy()`将字符串复制到字符数组中，第三个参数指定要复制的最大字符数。
    * `strcat()`将字符串附加到字符数组末尾。

* 由于不能通过键盘输入空字符，`cin`使用空白来确定字符串的结束位置（空格、制表符和换行符）。
    * `cin`提供了面向行的成员函数（类方法）：`getline()`和`get()`。
    * `getline()`通过回车键输入的换行符来确定输入结尾，并将**丢弃换行符**。`cin.getline(name, ArSize)`其第一个参数是**用来存储输入行的数组的名称**，第二个参数是**要读取的字符数**。
    * `get()`有两种变体。一种与`getline()`类似，接受的参数相同，但`get()`**并不再读取并丢弃换行符**；而不带任何参数的`cin.get()`可**读取下一个字符**（即使是换行符）。另一种是将两个成员函数拼接起来，如：`cin.get(name, ArSize).get()`,**由于`cin.get(name, ArSize)`返回一个`cin`对象**，随后可调用`get()`函数。
    * `get()`可用于判读停止读取的原因是读取了整行还是由于数组已填满。**因此，`getline()`使用起来更简单，而`get()`使得检测错误更简单**。
    * `get()`读取空行后将设置失效位（failbit）。可使用`cin.clear()`命令来恢复。
    * 如果输入行包含的字符数比指定的多，则`getline()`和`get()`将把余下的字符留在输入队列中，而`getline()`还会设置失效位，并关闭后面的输入。

***
* 使用string类，需要包含头文件string。
    * string类**位于名称空间std中**。
    * string类隐藏了字符串的数组性质，可自动调整长度，让程序员像处理普通变量那样处理字符串。
    * 不能将一个数组赋给另一个数组，但可以将一个string对象赋给另一个string对象。
    * 可使用运算符`+`将两个string对象合并起来。
    * `getline(cin,str)`将`cin`读取的输入保存到`str`中，此处的`getline()`不是类方法。

***
* **结构是用户定义的类型**，结构声明定义了这种类型的数据属性。创建结构包括两步：
    * 首先定义结构描述，描述并标记了能够存储在结构中的各种数据类型。
    * 然后按描述创建结构变量（结构数据对象）。

    * 列表中的每一项都被称为**结构成员**，可使用成员运算符`.`来访问各个成员。
    * C++允许在声明结构变量时**省略关键字`struct`**。
    * 可以同时完成定义结构和创建结构变量的工作，甚至初始化创建的变量，只需将变量名和初始化放在结束括号的后面即可。

* C++不提倡使用外部变量，但提倡使用外部结构声明。
* 结构可**使用列表初始化**，等号`=`可省略，不允许缩窄转换。
* 可以将结构作为参数传递给函数，也可以让函数返回一个结构。
* 可以将结构赋值给另一个同类型的结构。

* 可以创建元素为结构的数组，方法与创建基本类型数组完全相同。

* C++允许指定占用特定位数的结构成员，可以使用没有名称的字段来提供间距。每个成员都被称为**位字段**（位字段通常用在低级编程中）。

***
* **共用体是一种数据格式**，它能够存储不同的数据类型，但只能同时存储其中的一种类型。
    * 使用关键字`union`定义共用体。
    * 共用体的长度是其最大成员的长度。
    * 共用体常用于节省内存。
    * 共用体常用于操作系统数据结构或硬件数据结构。

***
* **枚举**提供了另一种创建符号常量的方式，这种方式可以替代`const`。它还允许定义新类型，但必须按严格的限制进行。
    * 使用关键字`enum`定义枚举。
    * 符号常量叫做**枚举量**。默认情况下将整数依次赋给枚举量（从0开始）。
    * 可用枚举名来声明这种类型的变量。
    * 在不进行强制类型转换时，只能将定义枚举时使用的枚举量赋给该枚举的变量。
    * 对于枚举变量，只定义了赋值运算符。
    * 枚举量是整型，可被提升为`int`类型，但`int`类型不能自动转换为枚举类型。
    * 可在算术表达式中同时使用枚举和常规整数。

* **枚举更常被用来定义相关的符号常量**。如果打算只使用常量，而不创建枚举类型的变量，则可省略枚举类型的名称。
    * 可创建多个值相同的枚举量。

* **每个枚举都有取值范围**，通过强制类型转换，可以将取值范围中的任何整数值赋给枚举变量，即使这个值不是枚举值。
    * 找出上限：找到大于这个最大值的、最小的2的幂，将它减去1便得到取值范围的上限。
    * 找出下限：若最小值不小于0，则取值范围的下限为0；否则，采用与寻找上限相同的方式，但要加上负号。

***
* **指针是一个变量**，其存储的是值的地址，而不是值本身。（地址通常需要2个或4个字节）
    * 对变量应用**地址运算符`&`**，就可以获得它的地址。
    * 显示地址时，`cout`使用十六进制表示法。
    * 使用常规变量时，值是指定的量，而地址是派生的量。
    * 处理存储数据的策略刚好相反，它将地址视为指定的量，而将值视为派生量。
    * 对指针应用**解除引用运算符`*`**（间接值），可得到该地址存储的值。

* 指针声明**必须指定指针指向的数据的类型**，以便分配足够的内存。
    * 解除引用运算符`*`两边的空格是可选的，通常有两种写法：
        * C程序员使用格式`int *ptr`，强调`*ptr`是一个`int`类型的值；
        * C++程序员使用格式`int* ptr`，强调`int*`是一种指向`int`类型的指针。
    * **对每个指针变量名，都需要使用一个**`*`。如：`int *p1, p2;`将创建指针`p1`和变量`p2`。

* 在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。
* 一定要在对指针应用解除引用运算符`*`之前，将指针初始化为一个确定的、适当的地址。
* 要将数字值作为地址来使用时，应通过强制类型转换将数字转换为适当的地址类型，如：`pt = (int*) 0xB800000`。

* **指针的真正用武之地在于，在运行阶段分配未命名的内存以存储值。**

* 使用new来分配内存
    * new运算符：找到一个长度正确的内存块，并返回该内存块的地址。通用格式：`typeName* pointer_name = new typeName`,如：`int* pn = new int`。
    * `pn`指向一个**数据对象**。术语“数据对象”比“变量”更通用，它指的是为数据项分配的内存块。数据对象可以是结构，也可以是其他基本类型。
    * new分配的内存块通常与常规变量声明分配的内存块不同。**常规变量**的值都存储在**栈（stack）**的内存区域中，而**new**从**堆（heap）或自由存储区（free store）**的内存区域分配内存。

* 面向对象编程强调*在运行阶段进行决策*（根据实际需要的而定）；而面向过程编程强调*在编译阶段进行决策*（预先确定好）。
* 对与大型数据（如数组、字符串和结构）应使用new，这正是new的用武之地。
    * 静态联编：在编译时分配内存。如：通过声明来创建数组。
    * 动态联编：在运行时分配内存。如：使用new来创建数组。

* 使用delete来释放内存
    * delete运算符：将使用完后的内存归还给内存池。
    * 一定要配对地使用new和delete，否则将发生内存泄漏；
    * 不要使用delete来释放不是new分配的内存；
    * 不要使用delete释放同一内存块两次；
    * 如果使用`new[]`为数组分配内存，则应使用`delete[]`来释放（方括号`[]`表示释放整个数组）。
        * 不能使用`sizeof`来确定动态分配的数组包含的字节数。
        * new运算符返回第一个元素的地址，并提供了识别内存块中每个元素所需的全部信息。
        * 访问数组元素时，只要把指针当做数组名使用即可。（**C++将数组名解释为第一个元素的地址**）
    * 对空指针使用delete是安全的。

***
* **数组和指针基本等价**是C和C++的优点之一。（但也有缺点）
    * 数组和指针基本等价的原因在于**指针算术**。但也有区别：
        * 可以修改指针的值，而数组名是常量。
        * 对数组应用`sizeof`运算符得到数组的长度，但对指针应用`sizeof`运算符得到指针的长度。
    * 指针变量加1后，增加的量等于它指向的类型的字节数。如：`arr[1]`等价于`*(arr + 1)`。
    * C++将数组名解释为第一个元素的地址，而对数组名应用地址运算符`&`时，得到的是整个数组的地址。如：
        * `arr[0]`是占一个元素内存块的地址；
        * `&arr`是占整个数组元素内存块的地址。
        * **以上二者表示的地址相同，但概念完全不同！**

***
* 在C++中，字符串像数组名一样，也是第一个元素的地址。
* **C++不能保证字符串字面值被唯一地存储**。也就是说，如果程序多次使用字符串字面值，编译器将可能存储一个或多个副本。

* 如果给`cout`提供一个指针，它将打印地址。但如果指针的类型是`char*`，则`cout`将显示指向的字符串。
    * 若要显示字符串的地址，则必须将这种指针转换为另一种指针类型，如：`int*`。

***
* 使用new创建动态结构
    * 指向结构的指针使用箭头成员运算符`->`来访问结构的成员。
    * 例如`ps`是指向结构的指针，则`*ps`是结构本身：`ps->price`和`(*ps).price`都是合法的表达。

***
* **自动存储**（自动产生，自动消亡）
    * **在函数内部定义的常规变量**使用自动存储空间，被称为自动变量，是一个局部变量，通常存储在栈中（占用的内存是连续的），遵循后进先出的原则（LIFO）。
* **静态存储**（存在于执行期间）
    * 整个程序执行期间都存在的存储方式。一是**在函数外面定义变量**；二是**在声明变量时使用关键字`static`**。
* **动态存储**（由程序员管理）
    * **由new和delete来创建和回收**，存储在堆（自由存储空间）中，占用的内存不连续。
* **线程存储**（生命周期与所属线程一样）
    * 在多核处理器中常见，**使用关键字`thread_local`来声明**。