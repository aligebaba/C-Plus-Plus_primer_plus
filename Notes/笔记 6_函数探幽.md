# 笔记 6 -- 函数探幽    （第八章）

### <span id = "0">0. 目录</span>
* [1. C++内联函数](#1)
* [2. 引用变量](#2)
* [3. 默认参数](#3)
* [4. 函数重载](#4)
* [5. 函数模板](#5)

### <span id = "1">1. C++内联函数</span> --> [目录](#0)
* 内联函数是C++**为提高程序运行速度所做的一项改进**。
    * 常规函数与内联函数的主要区别不在于编写方式，而**在于C++编译器如何将它们组合到程序中**。

* 可执行程序由一组机器语言指令组成，每条指令都有特定的地址。**常规函数调用使程序跳到另一个地址（函数的地址），并在函数结束时返回**。

* **对于内联函数，编译器使用相应的代码替换函数调用**，因此程序无需跳到另一个位置去执行代码。内联函数的运行速度比常规函数稍快，但代价是需要占用更多的内存。
    * 应有选择地使用内联函数，比如代码执行时间很短且经常被调用的函数。

* 内联函数必须在函数声明或函数定义前加上关键词`inline`。
    * 如果函数定义在函数首次使用前出现，则函数定义可以充当函数原型，不必再另外提供函数原型。
    * 内联函数通常省略函数原型，使用函数定义替代。

### <span id = "2">2. 引用变量</span> --> [目录](#0)
* **引用是已定义的变量的别名**。
    * 引用变量的主要用途是用作函数的形参。通过将引用变量用作参数，函数将使用原始数据，而不是其副本。（与使用指针相似）
    * 使用`&`来声明引用。
    * **引用必须在声明时将其初始化**，而指针可以先声明后赋值。引用更接近const指针。
        * 不能通过赋值来设置引用。
    
* **按引用传递**，使被调用的函数能够访问调用函数中的变量。
    * 按引用传递时，被调用函数的引用参数被初始化为实参。
    * 按传递引用时，**实参应是变量**。
    * **仅当引用参数为const引用时，如果实参与引用参数不匹配，且满足下面两种情况时，C++将生成临时变量**：
        * 实参的类型正确，但不是左值；
        * 实参的类型不正确，但可以转换为正确的类型。
    * 应尽可能将引用形参声明为`const`：
        * 使用`const`引用可以避免无意中修改数据；
        * 使用`const`引用使函数能够处理`const`和非`const`实参，否则只能接受非`const`实参；
        * 使用`const`引用使函数能够正确生成并使用临时变量。
    
* 左值是可被引用的数据对象，例如：变量、数组元素、结构成员、引用、解除引用的指针。
* 非左值包括字面常量、包含多项式的表达式。

* 引用主要用于结构和类。使用方法与基本变量引用相同。
* 常规函数返回值是右值，而引用返回值是左值。返回引用的函数实际上是被引用的变量的别名。
    * **返回引用时，应避免返回函数中的临时变量和临时变量的指针**。（程序试图引用已经释放的内存，会崩溃）
    * 最简单的方法是，返回一个作为参数传递给函数的引用。
    * **若不允许给引用返回值赋值，则需将函数返回类型声明为`const`引用**。

* **继承**：将特性从一个类传递给另一个类。
    * 派生类继承了基类的方法。
    * **基类引用可以指向派生类对象**，无需进行强制类型转换。

* 使用引用参数的主要原因有两个：
    * 能够修改调用函数中的数据对象；
    * 通过传递引用而不是整个数据对象，可以提高程序的运行速度。

* 按值传递、按引用传递、按指针传递的指导原则：
    * 对于使用但不修改传递值的函数
        * 如果数据对象很小，则按值传递；
        * 如果数据对象是数组，则使用指针，并将指针声明为指向const的指针；（唯一的选择）
        * 如果数据对象是较大的结构，则使用const指针或const引用，以提高效率；
        * 如果数据对象是类，则使用const引用。
    
    * 对于修改调用函数中数据的函数
        * 如果数据对象是内置数据类型，则使用指针；
        * 如果数据对象是数组，则只能使用指针；
        * 如果数据对象是结构，则使用引用或指针；
        * 如果数据对象是类对象，则使用引用。
    
### <span id = "3">3. 默认参数</span> --> [目录](#0)
* 默认参数，当函数调用中**省略了实参时自动使用的一个值**。
    * 必须**通过函数原型来设置**默认值。
    * 必须从右向左添加默认值。要为某个参数设置默认值，则必须为它右边的所有参数提供默认值。
    * 实参安照从左到右的顺序依次赋给形参，不能跳过任何参数。

### <span id = "4">4. 函数重载</span> --> [目录](#0)
* 函数多态（函数重载）可以让程序员**使用多个同名的函数**。
    * C++使用上下文来确定要使用的重载函数版本。
* 函数重载的关键是函数的参数列表————也称为**函数特征标**。
    * C++允许定义名称相同的函数，条件是它们的特征标不同（与函数返回类型是否相同无关）。
    * 参数列表中，**参数的数目或对应位置的参数类型不同，则函数特征标不同**。
        * 类型引用和类型本身视为同一个特征标。
        * 不区分const变量和非const变量。
            * **将非const值赋给const变量是合法的，但反之是非法的**。
    * 使用被重载的函数时，需要在函数调用中使用正确的参数类型。

* 仅当函数基本上执行相同的任务，但使用不同形式的数据时，才应采用函数重载。

### <span id = "5">5. 函数模板</span> --> [目录](#0)
* 函数模板是通用的函数描述，它们使用泛型来定义函数，其中的**泛型可用具体的类型来替换**。
    * 模板并非函数定义，其类型是用参数表示的，因此模板特性有时也被称为**参数化类型**。

            template <typename AnyType>    // 函数原型和函数定义前必须都有模板定义。
            void Swap(AnyType &a, AnyType &b)
            {
                AnyType temp;
                temp = a;
                a = b;
                b = temp;
            }


    * 关键字`template`和`typename`（或`class`）是必须的，类型名可以任意选择（此处为`AnyType`）
    * 函数模板不能缩短可执行程序。最终的代码不包含任何模板，只包含为了程序生成的实际函数。
        * 常见的做法是，将模板放在头文件中。
    * **并非所有的参数都必须是模板参数类型**。

* 局限性：模板函数可能无法处理某些类型。
    * 无法为数组定义赋值操作。
    * 无法为数组、指针、结构定义乘法运算符。

* 显示具体化（explicit specialization）
    * 对于给定的函数名，可以有非模板函数、模板函数和显示具体化模板函数，以及它们的重载版本。
    * 显示具体化的原型和定义应以`template<>`打头，并通过名称来指出类型。
    * 具体化优先于常规模板函数，非模板函数优先于具体化和常规模板函数。

             template <> void Swap<job>(job &, job &)   // Swap<job>中的job可以省略。
         

* 实例化和具体化
    * 编译器使用模板为特定类型生成函数定义时，得到的是模板实例。
        * 隐式实例化，模板为**泛型**，程序调用模板函数时**提供参数类型**。
        * 显示实例化，直接命令编译器**创建特定的实例**。

                 template void Swap<int>(int &, int &)

        
    * **隐式实例化、显示实例化、显示具体化**统称为**具体化**。