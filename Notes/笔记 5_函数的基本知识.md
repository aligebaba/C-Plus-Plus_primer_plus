# 笔记 5 -- 函数的基本知识  （第七章）

* [1. 函数回顾](#1)
* [2. 函数参数和按值传递](#2)
* [3. const的用法，以及保护数据](#3)
* [4. 数组的地址](#4)
* [5. 函数与C-风格字符串](#5)
* [6. 函数与结构、string对象](#6)
* [7. 函数与array对象](#7)
* [8. 递归](#8)
* [9. 函数指针](#9)

### <span id = "1">1. 函数回顾</span>
* 没有返回值的函数被称为void函数；有返回值的函数将生成一个值，并将它返回给调用函数。
    * C++规定返回值不能是数组，但可以是其他任何类型————整数、浮点数、指针、结构、对象。
        * 可以将数组作为结构或对象的组成部分来返回。
    * **函数在执行遇到的第一个返回语句后结束**。
* 函数通过**将返回值复制到指定的CPU寄存器或内存单元中**，随后调用函数将查看该内存单元。

* C++的编程风格是将main()函数放在最前面，因为它通常提供了程序的整体结构。

* 函数原型描述了函数到编译器的接口，**它将函数返回值的类型以及参数的类型和数量告诉编译器**。
    * 函数原型不要求提供变量名，有类型列表就足够了。
    * C++中，不指定类型列表时应使用省略号。（通常仅当与接受可变参数的C函数交互时才需要这样做）
    * 仅当有意义时，原型化才会导致类型转换。

### <span id = "2">2. 函数参数和按值传递</span>
* C++通常按值传递参数，这意味着将数值传递给函数，然后函数将数值赋给一个新的变量。
    * 传递给函数的值被称为**实参**；用于接收传递值的变量被称为**形参**。
    * C++标准使用参数（**argument**）来表示实参，使用参量（**parameter**）来表示形参。

* **传递常规变量时，函数将使用该变量的拷贝**；**传递数组时，函数将使用原来的数组（传递数组的地址，也即指针）**。
    * 将数组地址作为参数可以节省复制整个数组所需的时间和内存。
    * 指针本身并没有指出数组的长度，因此**必须显示传递数组长度**。
        * 另一种方法是指定元素区间，通过传递两个指针来完成：一个指针标识数组的开头，另一个指针标识数组的结尾（指向最后一个元素后面的指针）
* **为了防止函数无意中修改数组的内容，可在声明形参时使用关键词**`const`，如：`const int *arr`或`const int arr[]`。
    * 这并不意味着原始数组必须是常量，而只是意味着不能在函数中修改数组的元素。

* **按值传递给函数时**，函数处理的是原始对象的副本；**按指向对象的指针传递给函数时**，函数能够操作原始对象。

* 编写特定的函数来处理特定的数据操作是有好处的（可靠性更高，修改和调试更方便）。构思程序时将存储属性与操作结合起来，便是朝OOP思想迈进了重要的一步。

### <span id = "3">3. const的用法，以及保护数据</span>
* 将关键词`const`用于指针，有两种不同的方式：
    * 第一种方法是让指针指向一个常量。

            int age = 39;
            const int * pt = &age;

        * 上述声明指出，`pt`指向一个`const int`，因此不能使用`pt`来修改这个值。但**并不意味着`pt`指向的值是一个常量，而只是意味着对`pt`而言这个值是常量**。（可以直接通过`age`变量来修改`age`的值，但不能使用`pt`指针来修改）
        * 引申：可将`const`变量的地址赋给指向`const`的指针，但不能赋给常规指针！
    
    * 第二种方法是将指针本身声明为常量。

            int age = 39;
            int const * pt = &age;
        
        * 不允许修改指针`pt`的值，但允许通过指针`pt`修改`age`的值。

* 将指针作为参数来传递时，可以使用指向`const`的指针来保护数据。

### <span id = "4">4. 数组的地址</span>
* 数组名被解释为数组第一个元素的地址；而**对数组名应用地址运算符`&`时，得到的是整个数组的地址**。

        short tell[10];
        cout << tell << endl;           // 显示tell[0]的地址，一个2字节内存块的地址。
        cout << &tell << endl;          // 显示数组tell[10]的地址，一个20字节内存块的地址。
        // short (*pas)[10] = &tell;    // 括号不能省略，(*pas)等价于数组名tell。
    
    * `tell`是一个**short指针**`short *`，`&tell`是一个**包含10个元素的short数组的指针**`short (*) [10]`（*数组的指针*）。
    * `short *pas[10]`是一个**由10个指向short的指针组成的数组**。（*指针数组*）

    * 要得到第一个元素的值时，只需对`tell`解除一次引用，但需要对`&tell`解除两次引用：`**&tell == * tell == tell[0]`

* 在C++中，**当（且仅当）用于函数头或函数原型值时，**`int *arr`和`int arr[]`**的含义才相同**，他们都意味着arr是一个数组指针。
    * **当指针指向数组的第一个元素时**，使用数组表示法；
    * **当指针指向一个独立的值时**，使用指针表示法。

* 二维数组的地址有两种表示方法：

        int data[3][4] = {{1,2,3,4}, {9,8,7,6}, {2,4,6,8}};
        int total = sum(data, 3);

        // sum()函数的原型有下面两种表示方法，第一个参数是二维数组的第一个元素的地址，第二个参数是二维数组的长度。
        int sum(int (*ar2)[4], int size);
        int sum(int ar2[][4], int size);

    * `ar2`可看作是一个二维数组的名称。

### <span id = "5">5. 函数与C-风格字符串</span>
* 将字符串作为参数时，意味着传递的是地址；可使用修饰符`const`来防止修改字符串参数。
* 不必将字符串长度作为参数传递给函数，**函数使用循环依次检查字符串中的每个字符，直到遇到结尾的空字符为止**。
* **函数无法返回一个字符串，但可以返回字符串的地址**，这样做的效率更高。

### <span id = "6">6. 函数与结构、string对象</span>
* 可以将一个结构赋给另一个结构，同样，也可以按值传递结构，函数也可以返回结构。

* 传递结构的方式有三种：**按值传递**、**按地址传递**、**按引用传递**。
    * 按值传递结构有一个缺点：如果结构非常大，则复制结构将增加内存要求，降低系统运行的速度。
    * 按地址传递时，可用修饰符`const`；访问成员使用成员运算符`->`。

* C-风格字符串与string对象的用途几乎相同，但与数组相比，string对象与结构更相似。可像对待内置类型一样对待string对象。

### <span id = "7">7. 函数与array对象</span>
* 模板array不仅可以储存基本数据类型，还可以储存类对象。

### <span id = "8">8. 递归</span>
* C++函数可以自己调用自己，这种功能被称为**递归**。（`main()`函数除外）

* 通常的方法是将递归调用放在if语句中：

        void recurs(argumentlist)
        {
            statements1
            if (test)
                recurs(arguments)
            statements2
        }

    * 如果`recurs()`进行了5次调用，则`statements1`部分将按函数调用的顺序执行5次，然后`statements2`部分将以与函数调用相反的顺序执行5次。
    * **每个递归调用都创建自己的一套变量。**

* 在需要将一项工作不断分为两项较小的、类似的工作时，递归非常有用。递归方法有时被称为分而治之策略（divide-and-conquer strategy）。

### <span id = "9">9. 函数指针</span>
* **函数的地址**是存储其机器语言代码的内存的起始地址。
    * **函数名就是函数的地址**（函数名后面不带括号和参数）。如：`think()`表示函数的返回值，而`think`表示函数的地址。

* 可以编写一个将另一个函数的地址作为参数的函数。可以在不同的时间传递不同函数的地址，也即在不同的时间使用不同的函数。

* 声明指向函数的指针时，**应指定函数的返回类型以及函数的特征标**（参数列表）。如：`double (*pf)(int)`中`pf`就是函数指针。
    * **C++也允许像使用函数名那样使用函数指针，从而`(*pf)`和`pf`为等价**（即使它们在逻辑上互相冲突）。

* 下面四个函数原型的特征标看似不同，实际是相同的。

        const double * f1(const double ar[], int n);
        const double * f2(const double [], int n);
        const double * f1(const double *ar, int n);
        const double * f3(const double *, int n);
    
    * 在函数原型中，可以省略标识符；而在函数定义中则必须提供标识符。
    * 自动类型推断只能用于单值初始化，不能用于初始化列表。

* 可使用typedef来创建类型别名，减少输入量，在编写代码时更不易犯错。