# 笔记 2 -- 基本数据类型和算术运算符

* 内置的C++类型分为两组：基本类型和复合类型。**基本类型**（也称为**算术类型**）包括整数和浮点数；**复合类型**包括数组、字符串、指针和结构。

***
* C++提倡的变量命名规则：   （**一致性和精确性是最重要的**）
    * 在名称中只能使用字母、数字和下划线`_`；
    * 名称的第一个字符不能是数字；
    * 区分大写字母和小写字母；
    * 不能将C++关键字用作名称；
    * 以**两个下划线**或**一个下划线和大写字母**打头的名称被保留给实现使用。以**一个下划线**打头的名称被保留给实现，用作全局标识符。（**实现**，编译器及其使用的资源）
    * C++命名对长度没有限制，但有些平台有长度限制。

* **整型**包括`short`、`int`、`long`、`long long`、`char`型，每种类型都有**符号版**和**无符号版**。
    * 当前很多系统使用最小长度，即`short`为**16位**（2 bytes），`long`为**32位**（4 bytes），`long long`为**64位**（8 bytes）。64位win7系统中，`int`为**32位**（4 bytes）。
    * 无符号版在变量名前增加关键字`unsigned`，对于`unsigned int`可省略`int`。
    * 如果不对函数内部定义的变量进行初始化，该变量的值将是不确定的。
* 通常int被设置为对目标计算机而言最为“自然”的长度。
    * **自然长度**，指的是计算机处理起来效率最高的长度。
    * 如果没有特别的理由，则应使用`int`。
    * 仅当有大型整型数组时，才有必要使用`short`。

* **整型字面值**（数字常量）是显示地书写的常量。
    * 如果第一位为1~9，则基数为10（十进制）；
    * 如果第一位是`0`，第二位为1~7，则基数为8（八进制）；
    * 如果前两位为`0x`或`0X`，则基数为16（十六进制）。
* 数字常量的类型可使用后缀自定义和使用默认类型。
    * 后缀`L`表示为`long`常量，后缀`u`或`U`表示为`unsigned int`常量，后缀`LL`表示为`long long`常量等。
    * 对于不带后缀的十进制，使用能够存储该数的最小类型来表示：`int`、`long`、`long long`。
    * 对于不带后缀的八进制、十六进制，使用能够存储该数的最小类型来表示：`int`、`unsigned int`、`long`、`unsigned long`、`long long`、`unsigned long long`。

* `const`限定符，用于符号常量声明，**必须在声明中对`const`初始化**，初始化后其值就被固定了，编译器将不允许再修改该常量的值。
    * 通常将符号常量的首字母大写，或者整个名称大写。

* 在默认情况下，`cout`以十进制格式显示整数。
    * 控制符`dec`、`oct`、`hex`分别用于指示`cout`以十进制、八进制、十六进制格式显示整数。

* `char`类型：字符和小整型。
    * `char`字符，表示计算机系统中的所有基本符号————包括字母、数字、标点符号、转移序列等。（不超过128个）
    * `char`小整型在默认情况下不是没有符号，也不是有符号。（显式设置）`signed char`的范围为-128\~127，`unsigned char`的范围为0\~255。
    * **字符**用单引号`''`,**字符串**用双引号`""`。

* `wchar_t`类型：宽字符类型
    * 使用`wcin`和`wcout`来处理输入输出流。
    * 加上**前缀`L`来指示宽字符常量和宽字符串常量**。
* C++新增了类型`char_16`和`char_32`，都是无符号的。使用**前缀`u`表示`char_16`字符常量和字符串常量**，使用**前缀`U`表示`char_32`字符常量和字符串常量**。
* C++新增了原始字符串，在原始字符串中，字符表示的就是自己，例如：`\n`不表示换行符，而是`\`和`n`。
    * 使用前缀`R`来表示原始字符串，将`"(`和`)"`用作定界符。可在定界符之间添加任意数量的基本字符，但空格、左/右括号、斜杠和控制字符除外。
    * 输入原始字符串时，按回车键不仅会移到下一行，还将添加回车字符。

* C++将非零值解释为`true`，将零解释为`false`。

* `sizeof`运算符返回**类型**或**变量**的长度，单位为字节。
    * 对类型名使用`sizeof`运算符时，应将名称放在括号中。
    * 对变量名使用`sizeof`运算符时，括号可有可无。

***
* 计算机将浮点数分成两部分存储：一部分表示**值**，另一部分用于**对值进行放大或缩小**。
    * C++基于二进制数来表示，因此**缩放因子是2的幂**。

* C++有两种书写浮点数的方式：
    * 标准的小数点表示法，如：`3.14`。
    * E或e表示法，如：`8.33E-4`。（数字中间不能有空格）

* C++有3种浮点类型：`float`、`double`和`long double`。这些类型是按它们可以表示的有效数位和允许的指数最小范围来描述的。
    * 有效位是数字中有意义的位，不依赖于小数点的位置。
    * 通常，`float`的有效位为**32位**，`double`为**64位**，`long double`为**80、96或128位**。指数范围至少是-37\~37。
    * 表示的范围比整型大得多，但运算速度通常比整型慢，且精度降低。
* 浮点常量：
    * 默认情况下，浮点常量都是`double`型；
    * `f`或`F`后缀表示`float`型，`l`或`L`后缀表示`long double`型（通常不使用`l`）。

* 通常`cout`会删除结尾的零，调用`cout.setf()`将覆盖这种行为。此时，`float`至少有6位有效位，`double`至少有15位有效位。

***
* C++基本算术运算符：
    * `+`运算符
    * `-`运算符
    * `*`运算符
    * `/`运算符，**如果两个操作数都是整数**，则结果的小数部分将被丢弃；**如果其中一个操作数是浮点数**，则小数部分将被保留。
    * `%`求模运算符，两个操作数必须是整型。适用于解决将一个量分成不同的整数单元的情况。

***
* C++自动执行很多类型转换：
    * 将一个算术类型的值赋给另一个算术类型的变量时，C++将对值进行转换；
    * 表达式中包含不同类型时，C++将对值进行转换；
    * 将参数传递给函数时，C++将对值进行转换。

* 将一个值赋给取值范围更大的类型时，通常不会导致什么问题。
    * 将浮点型转换为整型，小数部分丢失、超出范围时结果不确定；
    * 将较大的整型转换为较小的整型，超出范围时只复制左边的字节；
    * 将较大的浮点型转换为较小的浮点型，有效位降低、超出范围时结果不确定。

* 列表初始化，使用大括号的初始化，常用于给复杂的数据类型提供值列表。
    * 为变量赋值时，可省略等号；
    * **不允许缩窄**（即变量的类型可能无法表示赋值给它的值）。

* 表达式中的转换
    * 自动**整型提升**：C++先将`bool`、`char`、`unsigned char`、`signed char`和`short`的值转换为`int`，最后将结果转换为所需类型。
    * 如果`short`比`int`短，则`unsigned short`类型被转换为`int`；如果`short`与`int`长度相同，则`unsigned short`类型被转换为`unsigned int`。
    * `wchar_t`被提升为下列类型中第一个满足其取值范围的类型：`int`、`unsigned int`、`long`、`unsigned long`。
    * 当运算涉及两种类型时，较小的类型将被转换为较大的类型。

* C++引入了4个强制类型转换运算符，`static_cast<>`用于将值从一种类型转换为另一种类型，原型如下：
    * `static_cast<typeName> (value)`