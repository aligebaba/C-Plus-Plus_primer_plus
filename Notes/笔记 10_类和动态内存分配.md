# 笔记 10 -- 对象和类    （第十二章）

### <span id = "0">0. 目录</span>
* [1. 动态内存和类](#1)
* [2. 在构造函数中使用new时应注意的事项](#2)
* [3. 有关返回对象的说明](#3)
* [4. 对象数组](#4)
* [5. 类作用域](#5)
* [6. 抽象数据类型](#6)

### <span id = "1">1. 动态内存和类</span> --> [目录](#0)
* C++中使用new和delete运算符来动态控制内存，但在类中使用这些运算符将导致许多新的编程问题。在这种情况下，析构函数是必不可少的，有时候还必须重载赋值运算符，以保证程序正常运行。

* 静态成员变量有一个特点：无论创建了多少对象，程序只创建一个静态成员变量副本。
    * 不能在类声明中初始化静态成员变量，因为声明描述了如何分配内存，但并不分配内存。（例外：const整型或枚举型）

* 字符串并不保存在对象中，而是保存在堆内存中，对象仅保存了指出到哪里查找字符串的信息。

* 删除对象可以释放对象本身占用的内存，但并不能释放属于对象成员的指针所指向的内存。必须使用析构函数。

* 当使用一个对象来**初始化**另一个对象时，编译器将自动生成**复制构造函数**，原型如下：
        
        Class_name(const Class_name &)  // 复制构造函数，创建对象的一个副本

        // 举例：
        StringBad(const StringBad &)

        // 下面两种初始化形式等效。
        StringBad sailor = sports;      // 调用隐式复制构造函数、隐式赋值运算符
        StringBad sailor = StringBad(sports);
    
    * 新建一个对象并将其初始化为同类现有对象时，将调用复制构造函数。
    * 每当程序生成对象副本时，将调用复制构造函数。
        * 按值传递对象
        * 函数返回对象
    
* 默认的复制构造函数逐个复制非静态成员（也称为**浅复制**），复制的是成员的值。
    * 如果累中包含了使用new初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据而不是指针，称为**深度复制**。

* 赋值运算符的隐式实现也对成员进行逐个复制，处理的方法与复制构造函数相同。
    * 赋值运算符是只能由类成员函数重载的运算符之一。

* 关键字nullptr表示**空指针**。

* 可以将成员函数声明为静态的：
    * 不能通过对象调用静态成员函数，甚至不能使用this指针。静态成员函数在公有部分声明时，可以使用类名和作用域解析符来调用它。
    * 不与特定的对象相关联，因此只能使用静态数据成员。
    * 可以使用静态成员函数设置类级标记，以控制某些类接口的行为。

### <span id = "2">2. 在构造函数中使用new时应注意的事项</span> --> [目录](#0)
* 如果在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete。

* new和delete必须互相兼容。new对应于delete，new[/]对应于delete[]。

* 如果有多个构造函数，则必须以相同的方式使用new，要么都带方括号，要么都不带。

* 应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象。

* 应定义一个赋值运算符，通过深度复制将一个对象赋值给另一个对象。

### <span id = "3">3. 有关返回对象的说明</span> --> [目录](#0)
* 可以返回指向对象的引用、指向对象的const引用或const对象。
    * 有些方法和函数可以返回对象，也可以返回指向对象的引用，在这种情况下，应首选引用，因为效率更高。

* 返回指向const对象的引用
    * 返回对象将调用复制构造函数，而返回引用不会。
    * 引用指向的对象应该在调用函数执行时存在。
    * 形参为const引用时，返回类型必须为const，这样才匹配。

* 返回指向非const对象的引用
    * 两种常见的情形是：重载赋值运算符；重载与cout一起使用的<<运算符。前者旨在提高效率，后者必须这样做。

* 返回对象
    * 如果被返回的对象是被调用函数中的局部变量，则不应按引用方式返回它，因为在被调用函数执行完毕时，局部对象将调用其析构函数。

* 返回const对象
    * 如果方法或函数要返回局部对象，则应返回对象，而不是指向对象的引用。
    * 如果方法或函数要返回一个没有公有复制构造函数的类的对象，它必须返回一个指向这种对象的引用。

### <span id = "4">4. 对象数组</span> --> [目录](#0)


### <span id = "5">5. 类作用域</span> --> [目录](#0)


### <span id = "6">6. 抽象数据类型</span> --> [目录](#0)
