# 笔记 10 -- 对象和类    （第十二章）

### <span id = "0">0. 目录</span>
* [1. 动态内存和类](#1)
* [2. 在构造函数中使用new时应注意的事项](#2)
* [3. this指针](#3)
* [4. 对象数组](#4)
* [5. 类作用域](#5)
* [6. 抽象数据类型](#6)

### <span id = "1">1. 动态内存和类</span> --> [目录](#0)
* C++中使用new和delete运算符来动态控制内存，但在类中使用这些运算符将导致许多新的编程问题。在这种情况下，析构函数是必不可少的，有时候还必须重载赋值运算符，以保证程序正常运行。

* 静态成员变量有一个特点：无论创建了多少对象，程序只创建一个静态成员变量副本。
    * 不能在类声明中初始化静态成员变量，因为声明描述了如何分配内存，但并不分配内存。（例外：const整型或枚举型）

* 字符串并不保存在对象中，而是保存在堆内存中，对象仅保存了指出到哪里查找字符串的信息。

* 删除对象可以释放对象本身占用的内存，但并不能释放属于对象成员的指针所指向的内存。必须使用析构函数。

* 当使用一个对象来**初始化**另一个对象时，编译器将自动生成**复制构造函数**，原型如下：
        
        Class_name(const Class_name &)  // 复制构造函数，创建对象的一个副本

        // 举例：
        StringBad(const StringBad &)

        // 下面两种初始化形式等效。
        StringBad sailor = sports;      // 调用隐式复制构造函数、隐式赋值运算符
        StringBad sailor = StringBad(sports);
    
    * 新建一个对象并将其初始化为同类现有对象时，将调用复制构造函数。
    * 每当程序生成对象副本时，将调用复制构造函数。
        * 按值传递对象
        * 函数返回对象
    
* 默认的复制构造函数逐个复制非静态成员（也称为**浅复制**），复制的是成员的值。
    * 如果累中包含了使用new初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据而不是指针，称为**深度复制**。

* 赋值运算符的隐式实现也对成员进行逐个复制，处理的方法与复制构造函数相同。
    * 赋值运算符是只能由类成员函数重载的运算符之一。

* 关键字nullptr表示**空指针**。

* 可以将成员函数声明为静态的：
    * 不能通过对象调用静态成员函数，甚至不能使用this指针。静态成员函数在公有部分声明时，可以使用类名和作用域解析符来调用它。
    * 不与特定的对象相关联，因此只能使用静态数据成员。
    * 可以使用静态成员函数设置类级标记，以控制某些类接口的行为。

### <span id = "2">2. 在构造函数中使用new时应注意的事项</span> --> [目录](#0)


### <span id = "3">3. this指针</span> --> [目录](#0)


### <span id = "4">4. 对象数组</span> --> [目录](#0)


### <span id = "5">5. 类作用域</span> --> [目录](#0)


### <span id = "6">6. 抽象数据类型</span> --> [目录](#0)
