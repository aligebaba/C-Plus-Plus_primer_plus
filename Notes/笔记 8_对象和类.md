# 笔记 8 -- 对象和类    （第十章）

### <span id = "0">0. 目录</span>
* [1. 抽象和类](#1)
* [2. 类的构造函数和析构函数](#2)
* [3. this指针](#3)
* [4. 对象数组](#4)
* [5. 类作用域](#5)
* [6. 抽象数据类型](#6)

### <span id = "1">1. 抽象和类</span> --> [目录](#0)
* 在C++中，**用户定义类型**指的是实现抽象接口的类设计。

* 指定基本类型时完成了三项工作：
    1. 决定数据对象需要的内存数量；
    2. 决定如何解释内存中的位；
    3. 决定可使用数据对象执行的操作或方法。

* 类规范由两个部分组成：
    1. 类声明：以**数据成员**的方式**描述数据部分**，以**成员函数**的方式**描述公有接口**。
    2. 类方法定义：描述如何实现类成员函数。  定义成员函数时，使用作用域解析运算符`::`来标识函数所属的类。

    * 类声明只是描述了对象的形式，并没有创建对象，因此没有用于存储值的空间。

* 通常，类名称首字母大写，数据成员使用`m_`前缀。
* 通常，C++程序员将接口（类定义）放在头文件中，将实现（类方法的代码）放在源代码文件中。
* **位于*类声明*中的函数都将自动成为内联函数**。（类声明常将短小的成员函数作为内联函数）
    * 使用inline限定符可使在类声明之外定义成员函数成为内联函数。
    * **将内联函数的定义放在头文件中**。（内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义）

* 使用类对象的程序都可以直接访问**公有部分**，但只能通过公有成员函数（或友元函数）来访问对象的**私有成员**。有以下三种访问控制方式：
    1. public：公有，结构的默认访问类型
    2. private：私有，类的默认访问类型
    3. protected：

    * 公有接口表示设计的**抽象组件**。将实现细节放在一起并将它们与抽象分开称为**封装**。
        * 数据项通常放在私有部分，成员函数放在公有部分。
        * 私有成员函数处理不属于公有接口的实现细节。

* 创建类对象，可以声明类变量，也可以使用new为类对象分配存储空间。
    * 每个对象都有自己的存储空间，用于存储其内部变量和类成员；但同一个类的所有对象共享同一组类方法。
    * 调用成员函数被称为**发送消息**。

### <span id = "2">2. 类的构造函数和析构函数</span> --> [目录](#0)
* 构造函数：用于构造新对象，将值赋给它们的数据成员。
    * **名称与类名相同**，原型位于类声明的公有部分。
    * **构造函数没有声明类型**。构造函数的函数原型和函数头没有返回值，但没有被声明为void类型。
    * 程序声明对象时，将自动调用构造函数。  无法使用对象来调用构造函数，因为在构造函数构造出对象之前，对象是不存在的。

* 调用构造函数的方式：

        Stock food = Stock("World Cabbage", 250, 1.25);     // 显式调用
        Sotck food("World Cabbage", 250, 1.25);             // 隐式调用

* **默认构造函数**是在未提供显式初始值时，用来创建对象的构造函数。
    * 当且仅当没有定义任何构造函数时，编译器会提供默认的构造函数。
    * 提供了构造函数后，程序员就必须提供默认构造函数，否则创建非初始化的对象时会出错。
* 定义默认构造函数的方式有两种：
    1. 通过函数重载，定义一个没有参数的构造函数。
    2. 给已有构造函数的所有参数提供默认值；
    * 通常应初始化所有的对象，可以提供对所有类成员做隐式初始化的默认构造函数。

* **析构函数**：对象过期时程序**自动调用**，用于完成清理工作。
    * 在类名前加上`~`。
    * 没有返回值、没有类型声明、没有参数。
    * 通常不应在代码中显式地调用析构函数。未提供析构函数时，编译器隐式地声明一个默认析构函数。

* **const成员函数**：*不修改调用对象*（与不修改调用函数的实参类似）。关键字const放在函数的括号后面。

        void show() const;

### <span id = "3">3. this指针</span> --> [目录](#0)
* 当方法（成员函数）涉及到两个对象时，需要使用C++的this指针。
    * this指针指向用来调用成员函数的对象，*this可表示对象本身。
    * 一般来说，所有的类方法都将this指针设置为*调用它的对象的地址*。

### <span id = "4">4. 对象数组</span> --> [目录](#0)
* 初始化对象数组的方案：
    1. 使用默认构造函数创建数组元素；
    2. 花括号中的构造函数创建临时对象；
    3. 将临时对象的内容复制到相应的元素中。

            Stock stocks[4] = {
                Stock("NanoSmart", 12, 20.0),
                Stock("Boffo Objects", 200, 2.0),
                Stock("Monolithic Obelisks", 130, 3.25),
                Stock("Fleep Enterprises", 60, 6.5)
            }

### <span id = "5">5. 类作用域</span> --> [目录](#0)
* C++引入了一个新的作用域：类作用域。
    * 在类中定义的名称（数据成员名、成员函数名）的作用域都为整个类，在类外是不可知的。
    * 使用类成员名时，必须根据上下文使用直接成员运算符`.`、间接成员运算符`->`、作用域解析运算符`::`。

* 有时候，使符号常量的作用域为类很有用。有两种方式可以达成目的：
    1. 在类中声明一个枚举。这种方式*不会创建类数据成员*。

            class Bakery
            {
            private:
                enum {Months = 12};
                double costs[Months];
                ...
            }
    2. 使用关键字static，使*该常量与其他静态常量存储在一起，而不是存储在对象中*。

          class Bakery
            {
            private:
                static Months = 12;
                double costs[Months];
                ...
            }

* 对于常规枚举类型，两个枚举定义中的枚举量不能相同，否则会发生冲突。
* 可以*使用关键字class或struct来限定枚举量的作用域*。使用时需要用枚举名来限定枚举量。

        enum class egg {Small, Medium, Large, Jumbo};
        enum struct t_shirt {Small, Medium, Large, Jumbo};

### <span id = "6">6. 抽象数据类型</span> --> [目录](#0)
* 抽象数据类型（abstract data type，ADT）：以通用的方式描述数据类型，而没有引入语言或实现细节。