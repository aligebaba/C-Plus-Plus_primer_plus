# 笔记 9 -- 对象和类    （第十一章）

### <span id = "0">0. 目录</span>
* [1. 运算符重载](#1)
* [2. 友元函数](#2)
* [3. 类的自动转换和强制类型转换](#3)

### <span id = "1">1. 运算符重载</span> --> [目录](#0)
* 运算符重载是C++的多态。C++根据操作数的数目和类型来决定采取哪种操作。

* **运算符函数**的格式如下：

        operator'op'(argument-list)     // 'op'必须是有效的C++运算符
        operator[]()                    // 重载数组索引运算符[]
                
        district = sid + sara;          // 运算符表示法，sid称为调用对象，sara称为被传递的对象。
        district = sid.operator+(sara); // 函数表示法

* 运算符重载的限制
    1. 必须至少有一个操作数是用户定义的类型；
    2. 不能违反运算符原来的句法规则；
    3. 不能创建新运算符；
    4. 不能重载下面的运算符：
        * 运算符`sizeof`
        * 成员运算符`.`
        * 成员指针运算符`.*`
        * 作用域解析运算符`::`
        * 条件运算符`?:`
        * RTTI运算符`typeid`    （RTTI，Runtime Type Identification，运行阶段类型识别）
        * 强制类型转换运算符`const_cast`、`dynamic_cast`、`reinterpret_cast`、s`tatic_cast`
    5. 大多数运算符可以通过成员或非成员函数进行重载，但下面的运算符只能通过成员函数进行重载：
        * 赋值运算符`=`
        * 函数调用运算符`()`
        * 下标运算符`[]`
        * 通过指针访问类成员运算符`->`
    6. 应在重载运算符时遵循一些明智的限制。

* 使用成员函数还是友元函数（非成员函数）来重载运算符？
    * 对于成员函数版本：一个操作数通过this指针隐式地传递，另一个操作数作为函数参数显式地传递。
    * 对于友元函数版本：两个操作数都作为参数来传递。
    * 根据类设计，使用友元函数版本可能更好，尤其是为类定义类型转换时。

### <span id = "2">2. 友元函数</span> --> [目录](#0)
* **友元**有3种类型：**友元函数**、**友元类**、**友元成员函数**。通过让函数成为类的友元，可以赋予该友元函数与类的成员函数相同的访问权限。
    * 友元函数需要访问哪个类的私有成员时，将该友元函数作为该类的友元即可。

* 创建友元函数的步骤：
    1. 将原型放在类声明中，并在原型声明前加上关键字`friend`。
        * 它不是成员函数，但与成员函数的访问权限相同。
    2. 编写函数定义时，不要使用类限定符，不要使用关键字`friend`。

* 常见的友元：重载<<运算符
    * cout是一个ostream对象，能识别所有的C++基本类型。这是因为对于每种基本类型，ostream类声明中都包含了相应的重载的operator<<()定义。
        * ostream类将operator<<()函数实现为返回一个指向ostream对象的引用。
    * 要重载<<运算符来显示c_name类的对象，可使用一个友元函数：

            ostream & operator<<(ostream & os, const c_name & obj)
            {
                os << ...;
                return os;
            }

### <span id = "3">3. 类的自动转换和强制类型转换</span> --> [目录](#0)
* 只接受一个参数的构造函数定义了**从参数类型到类类型的转换**。
    * 在原型声明前添加关键字`explicit`可以关闭自动转换，但仍可以显示转换。

            // 自动转换
            Stonewt(double lbs);
            Stonewt myCat;
            myCat = 19.6;

            // 显示转换
            explicit Stonewt(double lbs);
            Stonewt myCat;
            myCat = 19.6;           // ×
            myCat = Stonewt(19.6);  // √
            myCat = (Stonewt)19.6;  // √
    
    * 自动转换（隐式转换）有以下几种情况：
        * 将Stonewt对象初始化为double值时；
        * 将double值赋给Stonewt对象时；
        * 将double值传递给接受Stonewt参数的函数时；
        * 返回值被声明为Stonewt对象的函数试图返回double值时；
        * 在上述任意一种情况下，使用可转换为double类型的内置类型时。（**仅当转换不存在二义性时**）

* 要实现**从类类型到参数类型的转换**，必须使用特殊的C++运算符函数————**转换函数**
    * 转换函数是用户定义的强制类型转换，可以像使用强制类型转换那样使用它们。
    * 转换函数的形式如下：

            operator typeName()；   // typeName指出了要转换成的类型。
    
        * 转换函数必须是类方法；
        * 转换函数不能指定返回类型；
        * 转换函数不能有参数。
    
    * 当定义了两种或更多的转换函数时，仍可以用显示强制类型转换来指出要使用哪种转换函数。
    * 提供自动、隐式转换的函数所存在的问题是：在用户不希望进行转换时，转换函数也可能进行转换。
        * 原则上说，**最好使用显示转换，避免隐式转换**。
        * **使用关键字`explicit`可以关闭隐式转换**。