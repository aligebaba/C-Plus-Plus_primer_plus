# 笔记 11 -- 类继承    （第十三章）

### <span id = "0">0. 目录</span>
* [1. 基类](#1)
* [2. 多态公有继承](#2)
* [3. 静态联编和动态联编](#3)
* [4. 抽象基类（abstract base class，ABC）](#4)
* [5. 继承和动态内存分配](#5)
* [6. 类设计回顾](#6)

### <span id = "1">1. 基类</span> --> [目录](#0)
* 从一个类派生出另一个类时，原始类称为**基类**，继承类称为**派生类**。
    * 公有派生：基类的公有成员将成为派生类的公有成员；基类的私有成员也将成为派生类的一部分，但只能通过基类的公有和保护方法访问。
    * 派生类对象也是一个基类对象，可以对基类对象执行的任何操作，也可以对派生类对象执行。

    * 派生类需要自己的构造函数。
        * 派生类构造函数必须使用基类构造函数。
        * 除非使用默认构造函数，否则应显式调用正确的基类构造函数。
    * 派生类可以根据需要添加额外的数据成员和成员函数。

* 基类指针可以在不进行显式类型转换的情况下指向派生类对象；基类引用可以在不进行显式类型转换的情况下引用派生类对象。
    基类指针和引用只能用于调用基类方法。

### <span id = "2">2. 多态公有继承</span> --> [目录](#0)
* 有两种机制可用于实现多态公有继承：
    * 在派生类中重新定义基类的方法
        * 根据引用类型或指针类型选择方法。
    * 使用虚方法（常用）
        * 使用关键字virtual，只用于类声明的方法原型中，且在基类方法原型和派生类方法原型前都添加该关键字。
        * 根据引用或指针指向的对象的类型来选择方法。
        * 在基类中声明一个虚析构函数，确保释放派生对象时按正确的顺序调用析构函数。
            * 如果析构函数不是虚的，将只调用对应于指针类型的析构函数；如果析构函数是虚的，将调用相应对象类型的析构函数

### <span id = "3">3. 静态联编和动态联编</span> --> [目录](#0)
* 函数名联编（binding）：将源代码中的函数调用解释为执行特定的函数代码块。
    * 在**编译过程中**进行联编，称为**静态联编**，也称为早期联编；
    * 在**执行过程中**进行联编，称为**动态联编**，也称为晚期联编。
        * 动态联编与通过指针和引用调用方法相关。
    * 编译器对非虚方法使用静态联编，对虚方法使用动态联编。静态联编的效率更高。
    
* 将**派生类**引用或指针**转换为基类**引用或指针，称为**向上强制转换**。
    * 向上强制转换是可传递的。
* 将**基类**引用或指针**转换为派生类**引用或指针，称为**向下强制转换**。
    * 如果不使用显示类型转换，则向下强制转换是不允许的。

* 编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针，这个数组称为**虚函数表**。
    * 如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址；
    * 如果派生类没有重新定义虚函数，该虚函数表将保存函数原始版本的地址；
    * 如果派生类定义了新的虚函数，则该函数的地址也将被添加到虚函数表中。

* 虚函数注意事项：
    1. 构造函数不能是虚函数。
    2. 析构函数应当是虚函数，除非类不用做基类。
        * 即使基类不需要显式析构函数提供服务，也不应依赖默认构造函数。
    3. 友元不能是虚函数，因为友元不是类成员，而只有成员才能是虚函数。
    4. 如果派生类位于派生链中，则将使用最新的虚函数版本，例外的情况是基类版本是隐藏的。
    5. **如果重新定义派生类中的函数**，将不只是使用相同的函数参数列表覆盖基类声明，无论参数列表是否相同，该操作**将隐藏所有的同名基类方法**。（重新定义继承的方法并不是重载）
        * 两条经验规则：第一，如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。这种特性称为**返回类型协变**。
        * 第二，如果基类声明被重载了，则应在派生类中重新定义所有的基类版本。

### <span id = "4">4. 抽象基类（abstract base class，ABC）</span> --> [目录](#0)
* C++通过**纯虚函数**提供未实现的函数，纯虚函数声明的结尾处为`=0`。

* 当类声明中包含纯虚函数时，则不能创建该类的对象。**包含纯虚函数的类只用作基类**。
    * 要想成为真正的抽象基类，必须至少包含一个纯虚函数，在类中可以不定义该函数。

### <span id = "5">5. 继承和动态内存分配</span> --> [目录](#0)
* 当基类和派生类都采用动态内存分配时，派生类的析构函数、复制构造函数、赋值运算符都必须使用相应的基类方法来处理基类元素。
    * 对于析构函数，自动完成；
    * 对于复制构造函数，通过在初始化成员列表中调用基类的复制构造函数来完成；
    * 对于赋值运算符，通过使用作用域解析运算符显式地调用基类的赋值运算符来完成。

### <span id = "6">6. 类设计回顾</span> --> [目录](#0)
1. 默认构造函数
    * 默认构造函数要么没有参数，要么所有的参数都有默认值。
    * 如果定义了某种构造函数，编译器将不会定义默认构造函数。
    * 如果派生类构造函数的成员初始化列表中没有显式调用基类构造函数，则编译器将使用基类的默认构造函数来构造派生类对象的基类部分。
    * 如果类包含指针成员，则必须初始化这些成员。

2. 复制构造函数
    * 复制构造函数接受其所属类的对象作为参数。下述情况将使用复制构造函数：
        * 将新对象初始化为一个同类对象；
        * 按值将对象传递给函数；
        * 函数按值返回对象；
        * 编译器生成临时对象。
    * 在某些情况下，成员初始化是不合适的，例如使用new初始化的成员指针通常要求执行深复制。
    * 可显式定义复制构造函数。

3. 赋值运算符
    * 默认的赋值运算符用于处理同类对象之间的赋值。（注意与初始化区分开）
    * 如果派生类使用了new，则必须提供显式赋值运算符。必须给类的每个成员提供赋值运算符，而不仅仅是新成员。
    * 编译器不会生成将一种类型赋给另一种类型的赋值运算符，此时需要显式定义赋值运算符，或使用转换函数。

4. 析构函数
    * 一定要定义显式析构函数来释放类构造函数使用new分配的所有内存，并完成类对象所需的任何特殊的清理工作。
    * 对于基类，应提供一个虚析构函数。

5. 转换
    * 使用一个参数就可以调用的构造函数定义了从参数类型到类类型的转换。
        * 在上述构造函数原型中使用explicit将禁止进行隐式转换，但仍允许显式转换。
    * 要将类对象转换为其他类型，应定义转换函数。
        * 转换函数可以是没有参数的类成员函数，也可以是返回类型被声明为目标类型的类成员函数。
        * 即使没有声明返回类型，函数也应返回所需的转换值。

6. 按值传递对象与传递引用
    * 编写使用对象作为参数的函数时，应按引用而不是按值来传递对象。如果函数不修改对象，应将参数声明为const引用。
        * 在继承使用虚函数时，被定义为接受积累引用参数的函数可以接受派生类。

7. 返回对象和返回引用
    * 返回对象涉及返回对象的临时副本，这是调用函数的程序可以使用的副本。
    * 返回引用可以节省时间和内存，但不能返回在函数中创建的临时对象的引用，这种情况下应返回对象。

8. 使用const
    * 确保方法不修改参数；
        * 如果函数将参数声明为指向const的引用或指针，则不能将该参数传递给另一个函数，除非后者也确保了参数不会被修改。
    * 确保方法不修改调用它的对象；
    * 确保引用和指针返回的值不能用于修改对象中的数据。

        Star::Star(const char * s) {...}    // 不修改参数s
        
        void Star::show() const {...}       // 不修改调用它的对象

        const Stock & Stock::topval(const Stock & s) const    // 参数s、this为const，则返回的引用也必须为const
        {
            if (s.total_val > total_val)
                return s;
            else
                return *this;
        }

9. 友元函数
    * 友元函数并非类成员，因此不能继承。如果希望派生类的友元函数能够使用基类的友元函数，可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针。

10. 有关使用基类方法的说明
    * 派生类对象自动使用继承而来的基类方法；
    * 派生类的构造函数自动调用基类的构造函数；
    * 派生类的构造函数自动调用基类的默认构造函数，如果没有在成员初始化列表中指定其他构造函数；
    * 派生类的构造函数显式地调用成员初始化列表中指定的基类构造函数；
    * 派生类方法可以使用作用域解析运算符来调用公有的和受保护的基类方法；
    * 派生类的友元函数可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针，然后使用该引用或指针来调用基类的友元函数。