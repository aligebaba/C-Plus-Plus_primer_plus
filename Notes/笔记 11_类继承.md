# 笔记 11 -- 类继承    （第十三章）

### <span id = "0">0. 目录</span>
* [1. 基类](#1)
* [2. 多态公有继承](#2)
* [3. 静态联编和动态联编](#3)
* [4. 对象数组](#4)
* [5. 类作用域](#5)
* [6. 抽象数据类型](#6)

### <span id = "1">1. 基类</span> --> [目录](#0)
* 从一个类派生出另一个类时，原始类称为**基类**，继承类称为**派生类**。
    * 公有派生：基类的公有成员将成为派生类的公有成员；基类的私有成员也将成为派生类的一部分，但只能通过基类的公有和保护方法访问。
    * 派生类对象也是一个基类对象，可以对基类对象执行的任何操作，也可以对派生类对象执行。

    * 派生类需要自己的构造函数。
        * 派生类构造函数必须使用基类构造函数。
        * 除非使用默认构造函数，否则应显式调用正确的基类构造函数。
    * 派生类可以根据需要添加额外的数据成员和成员函数。

* 基类指针可以在不进行显式类型转换的情况下指向派生类对象；基类引用可以在不进行显式类型转换的情况下引用派生类对象。
    基类指针和引用只能用于调用基类方法。

### <span id = "2">2. 多态公有继承</span> --> [目录](#0)
* 有两种机制可用于实现多态公有继承：
    * 在派生类中重新定义基类的方法
        * 根据引用类型或指针类型选择方法。
    * 使用虚方法（常用）
        * 使用关键字virtual，只用于类声明的方法原型中，且在基类方法原型和派生类方法原型前都添加该关键字。
        * 根据引用或指针指向的对象的类型来选择方法。
        * 在基类中声明一个虚析构函数，确保释放派生对象时按正确的顺序调用析构函数。
            * 如果析构函数不是虚的，将只调用对应于指针类型的析构函数；如果析构函数是虚的，将调用相应对象类型的析构函数

### <span id = "3">3. 静态联编和动态联编</span> --> [目录](#0)


### <span id = "4">4. 对象数组</span> --> [目录](#0)


### <span id = "5">5. 类作用域</span> --> [目录](#0)


### <span id = "6">6. 抽象数据类型</span> --> [目录](#0)


